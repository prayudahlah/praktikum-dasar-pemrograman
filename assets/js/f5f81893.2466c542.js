"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["919"],{16547:function(e,n,t){t.r(n),t.d(n,{metadata:()=>o,contentTitle:()=>a,default:()=>u,assets:()=>c,toc:()=>d,frontMatter:()=>i});var o=JSON.parse('{"id":"external-stores/index","title":"State Management","description":"In case you want to store edited code blocks to a database instead of the browser\'s local storage, you can sync changes to docusaurus-live-brython by providing your own state management. This can be done by swizzling CodeEditor/hooks/useScript and CodeEditor/WithScript/ScriptContext. To sync between docusaurus-live-brython and your state management you can use reacts useSyncExternalStore hook.","source":"@site/docs/external-stores/index.md","sourceDirName":"external-stores","slug":"/external-stores/","permalink":"/praktikum-dasar-pemrograman/docs/external-stores/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"defaultSidebar","previous":{"title":"Meta-Comments","permalink":"/praktikum-dasar-pemrograman/docs/meta-comments/"},"next":{"title":"intro","permalink":"/praktikum-dasar-pemrograman/docs/materi/intro"}}'),s=t("85893"),r=t("50065");let i={sidebar_position:10},a="State Management",c={},d=[{value:"Mobx",id:"mobx",level:2}];function l(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.a)(),...e.components},{Details:t}=n;return!t&&function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"state-management",children:"State Management"})}),"\n",(0,s.jsxs)(n.p,{children:["In case you want to store edited code blocks to a database instead of the browser's local storage, you can sync changes to ",(0,s.jsx)(n.code,{children:"docusaurus-live-brython"})," by providing your own state management. This can be done by swizzling ",(0,s.jsx)(n.code,{children:"CodeEditor/hooks/useScript"})," and ",(0,s.jsx)(n.code,{children:"CodeEditor/WithScript/ScriptContext"}),". To sync between ",(0,s.jsx)(n.code,{children:"docusaurus-live-brython"})," and your state management you can use reacts ",(0,s.jsx)(n.code,{children:"useSyncExternalStore"})," hook."]}),"\n",(0,s.jsx)(n.h2,{id:"mobx",children:"Mobx"}),"\n",(0,s.jsxs)(n.p,{children:["\uD83D\uDC49 Demo Repository: ",(0,s.jsx)(n.a,{href:"https://github.com/lebalz/docusaurus-mobx-live-code",children:"lebalz/docusaurus-mobx-live-code"})]}),"\n",(0,s.jsxs)(n.p,{children:["Lets assume you have a ",(0,s.jsx)(n.code,{children:"DocumentStore"})," that stores ",(0,s.jsx)(n.code,{children:"Document"}),"s (which contain code blocks) and you want to sync changes to the ",(0,s.jsx)(n.code,{children:"DocumentStore"})," with ",(0,s.jsx)(n.code,{children:"docusaurus-live-brython"}),". This gives you the ability to store the code blocks in a database."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)(n.code,{children:"src/stores/DocumentStore"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/stores/documentStore.ts"',children:"import { action, computed, makeObservable, observable, override } from 'mobx';\nimport { RootStore } from './rootStore';\nimport { computedFn } from 'mobx-utils';\nimport Document from '../models/Document';\nimport { type RouterType } from '@docusaurus/types';\n\nexport class DocumentStore {\n    readonly root: RootStore;\n    static accessor libDir: string = '/bry-libs/';\n    static syncMaxOnceEvery: number = 1000;\n    static router: RouterType = 'browser';\n\n\n    documents = observable.array<Document>([]);\n    \n    constructor(root: RootStore) {\n        this.root = root;\n    }\n\n    @action\n    addDocument(document: Document) {\n        this.documents.push(document);\n    }\n\n    find = computedFn(\n        function (this: DocumentStore, id?: string): Document | undefined {\n            if (!id) {\n                return;\n            }\n            return this.documents.find((d) => d.id === id) as Document | undefined;\n        },\n        { keepAlive: true }\n    );\n\n}\n"})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)(n.code,{children:"src/models/Document.ts"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/models/Document.ts"',children:"import { action, computed, observable, reaction } from 'mobx';\nimport { DocumentStore } from '../stores/documentStore';\nimport { v4 as uuidv4 } from 'uuid';\nimport { sanitizePyScript, splitPreCode } from 'docusaurus-live-brython/theme/CodeEditor/WithScript/helpers';\nimport throttle from 'lodash/throttle';\nimport { \n    CANVAS_OUTPUT_TESTER, \n    DOM_ELEMENT_IDS, \n    GRAPHICS_OUTPUT_TESTER, \n    GRID_IMPORTS_TESTER, \n    TURTLE_IMPORTS_TESTER \n} from 'docusaurus-live-brython/theme/CodeEditor/constants';\nimport { \n    type InitState, \n    type LogMessage, \n    type Version,\n    Status\n} from 'docusaurus-live-brython/theme/CodeEditor/WithScript/Types';\nimport { runCode } from 'docusaurus-live-brython/theme/CodeEditor/WithScript/bryRunner';\n\n\nexport default class Document {\n    readonly store: DocumentStore;\n    readonly isVersioned: boolean;\n    readonly _pristineCode: string;\n    readonly id: string;\n    readonly codeId: string;\n    readonly source: 'local' | 'remote';\n    readonly _lang: 'py' | string;\n    readonly preCode: string;\n    readonly postCode: string;\n    @observable accessor createdAt: Date;\n    @observable accessor updatedAt: Date;\n    @observable accessor code: string;\n    @observable accessor isExecuting: boolean;\n    @observable accessor showRaw: boolean;\n    @observable accessor isLoaded: boolean;\n    @observable accessor status: Status = Status.IDLE;\n    @observable accessor graphicsModalExecutionNr: number; /* 0 = closed, >0 = open */\n    @observable accessor isPasted: boolean = false;\n    versions = observable.array<Version>([], {deep: false});\n    logs = observable.array<LogMessage>([], {deep: false});\n\n\n    constructor(props: InitState, store: DocumentStore) {\n        this.store = store;\n        this.id = props.id || uuidv4();\n        this.source = props.id ? 'remote' : 'local';\n        this._lang = props.lang;\n        this.isExecuting = false;\n        this.showRaw = false;\n        this.isLoaded = true;\n        this.isVersioned = props.versioned && this.source === 'remote';\n        this._pristineCode = props.code;\n        this.code = props.code;\n        if (this.isVersioned) {\n            this.versions.push({code: props.code, createdAt: new Date(), version: 1});\n        }\n        this.preCode = props.preCode;\n        this.postCode = props.postCode;\n        this.codeId = `code.${props.title || props.lang}.${this.id}`.replace(/(-|\\.)/g, '_');\n        this.updatedAt = new Date();\n        this.createdAt = new Date();\n    }\n\n    @action\n    clearLogMessages() {\n        this.logs.clear();\n    }\n\n    @action\n    setExecuting(isExecuting: boolean) {\n        this.isExecuting = isExecuting;\n    }\n\n    @action\n    addLogMessage(message: LogMessage) {\n        this.logs.push({output: message.output, timeStamp: Date.now(), type: message.type});\n    }\n\n    @action\n    setCode(code: string, action?: 'insert' | 'remove' | string) {\n        if (this.isPasted && action === 'remove') {\n            return;\n        }\n        this.code = code;\n        const updatedAt = new Date();\n        this.updatedAt = updatedAt;\n        if (this.isVersioned) {\n            this.addVersion({\n                code: code,\n                createdAt: updatedAt,\n                version: this.versions.length + 1,\n                pasted: this.isPasted\n            });\n        }\n        if (this.isPasted) {\n            this.isPasted = false;\n        }\n\n        /**\n         * call the api to save the code...\n         */\n    }\n\n    @action\n    loadVersions() {\n        // nop\n    }\n\n    \n    @action\n    _addVersion(version: Version) {\n        if (!this.isVersioned) {\n            return;\n        }\n        this.versions.push(version);\n    }\n\n    addVersion = throttle(\n        this._addVersion,\n        DocumentStore.syncMaxOnceEvery,\n        {leading: false, trailing: true}\n    );\n\n    @computed\n    get _codeToExecute() {\n        return `${this.preCode}\\n${this.code}\\n${this.postCode}`;\n    }\n\n    @action\n    execScript() {\n        if (this.hasGraphicsOutput) {\n            this.graphicsModalExecutionNr = this.graphicsModalExecutionNr + 1;\n        }\n        this.isExecuting = true;\n        runCode(this.code, this.preCode, this.postCode, this.codeId, DocumentStore.libDir, DocumentStore.router);\n    }\n\n    @action\n    saveNow() {\n        /**\n         * call the api to save the code...\n         */\n    }\n\n    /**\n     * stop the script from running\n     * wheter the script is running or not is derived from the\n     * `data--start-time` attribute on the communicator element.\n     * This is used in combination with the game loop\n     */\n    @action\n    stopScript() {\n        const code = document?.getElementById(DOM_ELEMENT_IDS.communicator(this.codeId));\n        if (code) {\n            code.removeAttribute('data--start-time');\n        }\n    }\n\n    @computed\n    get hasGraphicsOutput() {\n        return this.hasTurtleOutput || this.hasCanvasOutput || GRAPHICS_OUTPUT_TESTER.test(this._codeToExecute);\n    }\n\n    @computed\n    get hasTurtleOutput() {\n        return TURTLE_IMPORTS_TESTER.test(this._codeToExecute);\n    }\n\n\n    @computed\n    get hasCanvasOutput() {\n        return CANVAS_OUTPUT_TESTER.test(this._codeToExecute) || GRID_IMPORTS_TESTER.test(this._codeToExecute);\n    }\n\n    @computed\n    get hasEdits() {\n        return this.code !== this.pristineCode;\n    }\n\n    @computed\n    get versionsLoaded() {\n        return true;\n    }\n\n\n    @action\n    closeGraphicsModal() {\n        this.graphicsModalExecutionNr = 0;\n    }\n\n    subscribe(listener: () => void, selector: keyof Document) {\n        if (Array.isArray(this[selector])) {\n            return reaction(\n                () => (this[selector] as Array<any>).slice().length,\n                (curr, prev) => {\n                    listener();\n                }\n            );\n        }\n        return reaction(\n            () => this[selector],\n            listener\n        );\n    }\n\n    @computed\n    get pristineCode() {\n        return this._pristineCode;\n    }\n\n    @action\n    setIsPasted(isPasted: boolean) {\n        this.isPasted = isPasted;\n    };\n    @action\n    setShowRaw(showRaw: boolean) {\n        this.showRaw = showRaw;\n    };\n    @action\n    setStatus(status: Status) {\n        this.status = status;\n    };\n\n    get lang() {\n        if (this._lang === 'py') {\n            return 'python';\n        }\n        return this._lang;\n    }\n}\n"})})]}),"\n",(0,s.jsxs)(n.p,{children:["With the ",(0,s.jsx)(n.code,{children:"useSyncExternalStore"})," hook you can setup the synchronization between ",(0,s.jsx)(n.code,{children:"docusaurus-live-brython"})," and the ",(0,s.jsx)(n.code,{children:"Document"})," Model tracked by mobx."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/theme/CodeEditor/hooks/useScript.ts"',children:'import Document from "@site/src/models/Document";\nimport { useCallback, useSyncExternalStore } from "react";\nexport const useScript = <T extends keyof Document>(model: Document, selector: T): Document[T] => {\n    const isArray = Array.isArray(model[selector]);\n    if (isArray) {\n        // Arrays (logs and versions) are treated differently, see the details below\n    }\n    return useSyncExternalStore(\n        useCallback((callback) => {\n            return model.subscribe(callback, selector);\n        }, [model, selector]),\n        useCallback(\n            () => {\n                return model[selector];\n            },\n            [model, selector]\n        )\n    );\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"model"})," provides a ",(0,s.jsx)(n.code,{children:"subscribe"})," method, which sets up a reaction on changes on the specified ",(0,s.jsx)(n.code,{children:"selector"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/models/Document.ts"',children:"    subscribe(listener: () => void, selector: keyof Document) {\n        if (Array.isArray(this[selector])) {\n            return reaction(\n                () => (this[selector] as Array<any>).slice().length,\n                listener\n            );\n        }\n        return reaction(\n            () => this[selector],\n            listener\n        );\n    }\n"})}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsxs)("summary",{children:["Full ",(0,s.jsx)(n.code,{children:"useScript.ts"})," Source"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/theme/CodeEditor/hooks/useScript.ts"',children:'import Document from "@site/src/models/Document";\nimport { useCallback, useSyncExternalStore } from "react";\n/**\n * A utility function to create a stable snapshot wrapper\n * it is meant to only track the length of the array and treats\n * two arrays with the same length as equal\n */\nconst useStableSnapshot = (getSnapshot: () => Array<any>) => {\n    let prevLength: number = -1;\n    let prevResult: Array<any>;\n    return () => {\n        const result = getSnapshot();\n        if (result.length !== prevLength) {\n            prevLength = result.length;\n            prevResult = result.slice();\n        }\n        return prevResult;\n    };\n};\n\n\nexport const useScript = <T extends keyof Document>(model: Document, selector: T): Document[T] => {\n    const isArray = Array.isArray(model[selector]);\n    if (isArray) {\n        /**\n         * arrays are treated differently as they are expected to be\n         * immutable, so we can use a stable snapshot to track changes\n         * in the array\n         */\n        return useSyncExternalStore(\n            useCallback((callback) => {\n                return model.subscribe(callback, selector);\n            }, [model, selector]),\n            useCallback(\n                useStableSnapshot(() => {\n                    return model[selector] as Array<any>;\n                }) as () => Document[T],\n                [model, selector]\n            )\n        );\n    }\n    return useSyncExternalStore(\n        useCallback((callback) => {\n            return model.subscribe(callback, selector);\n        }, [model, selector]),\n        useCallback(\n            () => {\n                return model[selector];\n            },\n            [model, selector]\n        )\n    );\n}\n'})})]}),"\n",(0,s.jsxs)(n.p,{children:["Since the state in ",(0,s.jsx)(n.code,{children:"docusaurus-live-brython"})," is passed down through the ",(0,s.jsx)(n.code,{children:"ScriptContext"}),", you need to swizzle the ",(0,s.jsx)(n.code,{children:"ScriptContext"})," to provide the mobx ",(0,s.jsx)(n.code,{children:"Document"})," to the ",(0,s.jsx)(n.code,{children:"CodeEditor"})," and all of it's components."]}),"\n",(0,s.jsxs)(n.p,{children:["Here you can see, that the ",(0,s.jsx)(n.code,{children:"Document"})," is created when the ",(0,s.jsx)(n.code,{children:"ScriptContext"})," is mounted and added to the ",(0,s.jsx)(n.code,{children:"DocumentStore"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="src/theme/CodeEditor/WithScript/ScriptContext.tsx"',children:'import React from "react";\nimport { usePluginData } from "@docusaurus/useGlobalData";\nimport { observer } from "mobx-react-lite";\nimport { InitState } from "docusaurus-live-brython/theme/CodeEditor/WithScript/Types";\nimport Document from "@site/src/models/Document";\nimport { useStore } from "@site/src/hooks/useStore";\nimport BrowserOnly from \'@docusaurus/BrowserOnly\';\nimport CodeBlock from \'@theme/CodeBlock\';\nexport const Context = React.createContext<Document | undefined>(undefined);\nimport { v4 as uuidv4 } from \'uuid\';\n\nconst ScriptContext = observer((props: InitState & { children: React.ReactNode; }) => {\n    const [id, setId] = React.useState<string>(props.id || uuidv4());\n    const documentStore = useStore(\'documentStore\');\n    React.useEffect(() => {\n        const doc = documentStore.find(id);\n        if (doc) {\n            return;\n        }\n        const document = new Document({...props, id: id}, documentStore);\n        documentStore.addDocument(document);\n    }, [props.id, documentStore]);\n    \n    return (\n        <BrowserOnly fallback={<CodeBlock language={props.lang}>{props.code}</CodeBlock>}>\n            {() => {\n                if (!documentStore.find(id)) {\n                    return (<CodeBlock language={props.lang}>{props.code}</CodeBlock>);\n                }\n                return (\n                    <Context.Provider value={documentStore.find(id)}>\n                        {props.children}\n                    </Context.Provider>\n                );\n            }}\n        </BrowserOnly>\n    );\n});\n\nexport default ScriptContext;\n'})})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);